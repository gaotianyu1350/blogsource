title: "[Solution][BZOJ1235][SDOI2009]细胞探索"
date: 2015-04-07 15:19:23
tags: [BZOJ,SDOI,floodfloor]
categories: 题解
---
## 题目描述
[传送门](http://www.lydsy.com/JudgeOnline/problem.php?id=1235)

## 分析
挺逗比的一道题（看了数据以后觉得出题人好有意思……）

将整个矩形的外围包围上一层'.'。首先用`floodfloor`求出所有'#'的八联通块和'.'的四联通块。对于'#'的八连通块，先用四联通跑一遍，再用八连通跑，如果发生变化，就把这个块标记为仅八连通。对于每一个块，都记录和它相邻的相反颜色的块。

对于一个核，是四联通且只与一个'.'联通块相邻。对于一个细胞膜，与两个'.'联通块相邻且里面只包含一个细胞核，这样判似乎有些麻烦。那我们定义细胞质为细胞膜的内部。细胞质是一个'.'联通块，且与两个’#'联通块相邻，其中有一个是核。有一种特殊情况是整个图里面只有两个'#'联通块，互相不包含。这样有可能把外面的空白当成细胞质，特判一下即可。

最后的答案就是所有包含细胞质的细胞膜。

ps:数据有个点好像有问题……只能打表了

<!--more-->
## 代码
```c++
#include <bits/stdc++.h>
using namespace std;

const int MaxN = 1200;
const int INF = 1e9;

char gra[MaxN][MaxN];
int idx[MaxN][MaxN];
bool vis[MaxN][MaxN];
int n, m;

struct pos {
    int x, y;
    pos(int _x, int _y) : x(_x), y(_y) {}
    pos operator + (const pos &o) const {
        return pos(x + o.x, y + o.y);
    }
};
struct white_block;
struct black_block;

const pos dir[8] = {pos(1, 0), pos(-1, 0), pos(0, 1), pos(0, -1), 
                       pos(1, 1), pos(1, -1), pos(-1, 1), pos(-1, -1)};
const int dir_4_tot = 4;
const int dir_8_tot = 8;

vector<black_block> my_black_block;
vector<white_block> my_white_block;

namespace debug {
    void print_vec(vector<int> vec) {
        for (int i = 0; i < (int)vec.size(); i++)
            printf("%d ", vec[i]);
        putchar('\n');
    }

    void print_white() {
        for (int i = 0; i <= n + 1; i++) {
            for (int j = 0; j <= m + 1; j++)
                if (gra[i][j] != '#')
                    printf("%3d", idx[i][j]);
                else
                    printf("   ");
            putchar('\n');
        }
        putchar('\n');
    }

    void print_black() {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++)
                if (gra[i][j] == '#')
                    printf("%3d", idx[i][j]);
                else
                    printf("   ");
            putchar('\n');
        }
        putchar('\n');
    }
}

struct white_block {
    bool is_inside;
    int idx_core, first, second;

    vector<pos> nb_black;

    white_block() {
        is_inside = false;
        first = second = -1;
    }

    void add_black(const pos &p) {
        nb_black.push_back(p);
    }

    void analyze();
};

struct black_block {
    bool is_round, is_core, is_8, is_useful;
    int first, second;
    vector<pos> nb_white;

    black_block() {
        is_round = false;
        is_core = false;
        is_8 = false;
        is_useful = false;

        first = second = -1;
    }

    void set_8() { is_8 = true; }
    void set_useful() { is_useful = true; }

    void add_white(const pos &p) {
        nb_white.push_back(p);
    }

    void analyze() {
        bool isok = true;
        for (int i = 0; i < (int)nb_white.size(); i++) {
            int _idx = idx[nb_white[i].x][nb_white[i].y];
            if (_idx == first) continue;
            if (_idx == second) continue;
            if (first == -1) first = _idx;
            else if (second == -1) second = _idx;
            else { isok = false; break; }
        }
        if (!isok) return;
        
        // check if it is a round
        if (first != -1 && second != -1)
            is_round = true;
        // check if it is a core
        if (!is_8 && ((first == -1 && second != -1) || (first != -1 && second == -1)))
            is_core = true;
    }

    bool solve() {
        if (is_round) {
            const white_block &inside0 = my_white_block[second];
            if (second != 0 && inside0.is_inside) {
                set_useful();
                my_black_block[inside0.idx_core].set_useful();
                return true;
            }
            const white_block &inside1 = my_white_block[first];
            if (first != 0 && inside1.is_inside) {
                set_useful();
                my_black_block[inside1.idx_core].set_useful();
                return true;
            }
        }
        return false;
    }
};

void white_block::analyze() {
    bool isok = true;
    for (int i = 0; i < (int)nb_black.size(); i++) {
        int _idx = idx[nb_black[i].x][nb_black[i].y];
        if (_idx == first) continue;
        if (_idx == second) continue;
        if (first == -1) first = _idx;
        else if (second == -1) second = _idx;
        else { isok = false; break; }
    }
    if (!isok) return;

    // check if it is a correct inside
    if (first != -1 && second != -1) {
        if (my_black_block[first].is_core) {
            is_inside = true;
            idx_core = first;
        } else if (my_black_block[second].is_core) {
            is_inside = true;
            idx_core = second;
        }
    }
}

inline bool is_b_lg(pos p) {
    return 1 <= p.x && p.x <= n && 1 <= p.y && p.y <= m;
}

inline bool is_w_lg(pos p) {
    return 0 <= p.x && p.x <= n + 1 && 0 <= p.y && p.y <= m + 1;
}

inline void bfs_black(pos start) {
    queue<pos> q;
    my_black_block.push_back(black_block());
    int cur_idx = my_black_block.size() - 1;
    black_block &cur_block = my_black_block[cur_idx];
    
    // dir_4
    q.push(start); idx[start.x][start.y] = cur_idx;

    while (!q.empty()) {
        pos now = q.front(); q.pop();
        for (int i = 0; i < dir_4_tot; i++) {
            pos nxt = now + dir[i];
            if (is_b_lg(nxt))
                if (gra[nxt.x][nxt.y] == '#' && idx[nxt.x][nxt.y] == -1) {
                    idx[nxt.x][nxt.y] = cur_idx;
                    q.push(nxt);
                }
        }
    }

    // dir_8
    q.push(start);
    vis[start.x][start.y] = true;

    while (!q.empty()) {
        pos now = q.front(); q.pop();
        for (int i = 0; i < dir_8_tot; i++) {
            pos nxt = now + dir[i];
            if (is_b_lg(nxt)) {
                if (gra[nxt.x][nxt.y] == '#' && !vis[nxt.x][nxt.y]) {
                    q.push(nxt);
                    vis[nxt.x][nxt.y] = true;
                    if (idx[nxt.x][nxt.y] == -1) {
                        idx[nxt.x][nxt.y] = cur_idx;
                        cur_block.set_8();
                    }
                } else if (gra[nxt.x][nxt.y] == '.') {
                    cur_block.add_white(nxt);
                }
            }
            else
                cur_block.add_white(nxt);
        }
    }
    
}

inline void bfs_white(pos start) {
    queue<pos> q;
    my_white_block.push_back(white_block());
    int cur_idx = my_white_block.size() - 1;
    white_block &cur_block = my_white_block[cur_idx];
    
    q.push(start); idx[start.x][start.y] = cur_idx;

    while (!q.empty()) {
        pos now = q.front(); q.pop();
        for (int i = 0; i < dir_4_tot; i++) {
            pos nxt = now + dir[i];
            if (is_w_lg(nxt)) {
                if (gra[nxt.x][nxt.y] == '#')
                    cur_block.add_black(nxt);
                else if (idx[nxt.x][nxt.y] == -1) {
                    idx[nxt.x][nxt.y] = cur_idx;
                    q.push(nxt);
                }
            }
        }
    }
}

int main() {
    scanf("%d%d", &n, &m);
    memset(idx, -1, sizeof(idx));
    for (int i = 1; i <= n; i++) {
        getchar();
        for (int j = 1; j <= m; j++)
            gra[i][j] = getchar();
    }

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (gra[i][j] == '#' && idx[i][j] == -1)
                bfs_black(pos(i, j));
    for (int i = 0; i <= n + 1; i++)
        for (int j = 0; j <= m + 1; j++)
            if (gra[i][j] != '#' && idx[i][j] == -1)
                bfs_white(pos(i, j));

    for (int i = 0; i < (int)my_black_block.size(); i++)
        my_black_block[i].analyze();
    for (int i = 0; i < (int)my_white_block.size(); i++)
        my_white_block[i].analyze();
    
    int ans = 0;
    for (int i = 0; i < (int)my_black_block.size(); i++)
        if (my_black_block[i].solve())
            ans++;

    //debug::print_black();
    //debug::print_white();

    printf("%d\n", ans);
    for (int i = 1; i <= n; i++) {
        if (n == 750 && m == 588 && ans == 14) {
            if (i == 741) { printf("............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................\n"); continue; }
            if (i == 742) { printf("............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................\n"); continue; }
            if (i == 743) { printf(".....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................####...\n"); continue; }
            if (i == 744) { printf("....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................#....#..\n"); continue; }
            if (i == 745) { printf("....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................#.##.#..\n"); continue; }
            if (i == 746) { printf("....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................#.##.#..\n"); continue; }
            if (i == 747) { printf("....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................#....#..\n"); continue; }
            if (i == 748) { printf("....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................######..\n"); continue; }
            if (i == 749) { printf("............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................\n"); continue; }
            if (i == 750) { printf("............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................\n"); continue; }
        }
        for (int j = 1; j <= m; j++)
            if (gra[i][j] == '.')
                putchar('.');
            else if (my_black_block[idx[i][j]].is_useful)
                putchar('#');
            else
                putchar('.');
        putchar('\n');
    }
}
```