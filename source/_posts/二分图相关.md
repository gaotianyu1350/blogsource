title: 二分图相关
date: 2015-02-06 10:04:21
tags: [二分图,KM,匈牙利算法,独立集,偏序集]
categories: 题解
---
<!--more-->
> 注：一下资料转自[这里](http://endlesscount.blog.163.com/blog/static/821197872012622103810976/)，然后加入了一点自己的东西

## 二分图最大匹配

定义：匹配是图中一些边的集合，且集合中任意两条边都没有公共点，所有的匹配中，边数最多的就是最大匹配。

算法：`匈牙利算法`或`最大流`。下面是`匈牙利算法`的代码
```
bool find(int x) {
    for (int i = 1; i <= n; i++)
        if (map[x][i] && !check[i]) {
            check[i] = true;
            if (!result[i] || find(result[i])) {
                result[i] = x;
                return true;
            }
        }
    return false;
}
int main() {
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        memset(check, 0, sizeof(check));
        if (find(i))
            ans++;
    }
}
```
`匈牙利算法`的复杂度是$O(VE)$的。

## 二分图最小点覆盖

定义：点覆盖是图中一些点的集合，且对于图中所有的边，至少有一个端点属于点覆盖，点数最小的覆盖就是最小点覆盖。

定理：最小点覆盖=最大匹配

证明：首先最小点覆盖不可能小于最大匹配（因为那样一定会有边无法被覆盖），而且相等的情况是存在的（把最大匹配中的边都覆盖，由于不可能还有两个点都没有被覆盖的边，所以覆盖完成），所以最小点覆盖=最大匹配。

## 二分图最小边覆盖

定义：边覆盖是图中一些边的集合，且对于图中所有的点，至少有一条集合中的边与其相关联，边数最小的覆盖就是最小边覆盖。

定理：最小边覆盖=图中点的个数-最大匹配。

证明：先贪心的选一组最大匹配的边加入集合，对于剩下的每个未匹配的点，随便选一条与之关联的边加入集合，得到的集合就是最小边覆盖，所以有：最小边覆盖=最大匹配+图中点的个数-2*最大匹配=图中点的个数-最大匹配。

## 二分图最大独立集

定义：独立集是图中一些点的集合，且图中任意两点之间都不存在边，点数最大的就是最大独立集。

定理：最大独立集=图中点的个数-最大匹配。

简单证明：可以这样来理解，先把所有的点都加入集合，删除最少的点和与其关联的边使得剩下的点相互之间不存在边，我们就得到了最大独立集。所以有：最大独立集=图中点的个数-最小点覆盖=图中点的个数-最大匹配。

## 有向无环图最小不相交路径覆盖

定义：用最少的不相交路径覆盖所有顶点。

定理：把原图中的每个点$V$拆成$Vx$和$Vy$，如果有一条有向边$A->B$，那么就加边$Ax-By$。这样就得到了一个二分图，最小路径覆盖=原图的节点数-新图最大匹配。

证明：一开始每个点都独立的为一条路径，总共有$n$条不相交路径。我们每次在二分图里加一条边就相当于把两条路径合成了一条路径，因为路径之间不能有公共点，所以加的边之间也不能有公共点，这就是匹配的定义。所以有：最小路径覆盖=原图的节点数-新图最大匹配。

## 有向无环图最小可相交路径覆盖

定义：用最小的可相交路径覆盖所有顶点。

算法：先用floyd求出原图的传递闭包，即如果$a$到$b$有路，那么就加边$a->b$。然后就转化成了最小不相交路径覆盖问题。

## 偏序集的最大反链

定义：在偏序集$X$中。链是指一个集合$S$，$S$中的元素互相都有偏序关系。而反链则是指元素相互之间都没有关系的集合。偏序集中的最大反链，其实也就是偏序集中的最大独立集（只要能够到达都算相连）。

定理：`Dilworth定理`，对于任何偏序集，都有最大反链=最小链的划分，最大链=最小反链的划分。

通过`Dilworth定理`，我们可以把偏序集中的最大反链问题转化为最小可相交路径覆盖问题。

## 二分图最大完美匹配

 定义：每个边都有一组权值，边权之和最大的完美匹配就是最大完美匹配。
 
算法：KM算法，复杂度为$O(V^3)$。或者用费用流。

要注意的是，`KM算法`求的是完美匹配，即在匹配是完备的基础上权值之和最大。这和带权最大匹配是不一样的，不过我们可以加入若干条边权为0的边使得`KM`求出来的最佳匹配等于最大权匹配。具体实现的时候最好用矩阵来存图。如果要求最小权匹配，我们可以用一个很大数减去每条边的边权。

下面是`KM`算法的代码：

```
bool find(int x) {
    luse[x] = true;
    for (int i = 1; i <= n; i++)
        if (!ruse[i]) {
            int temp = l[x] + r[i] - gap[x][i];
            if (!temp) {
                ruse[i] = true;
                if (!result[i] || find(result[i])) {
                    result[i] = x;
                    return true;
                }
            }
            else
                slack[i] = min(slack[i], temp);
    }
    return false;
}
inline int km() {
    memset(result, 0, sizeof(result));
    memset(l, 0, sizeof(l));
    memset(r, 0, sizeof(r));
    for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
        l[i] = max(l[i], gap[i][j]);
    for (int i = 1; i <= n; i++) {
        memset(slack, 0x7f, sizeof(slack));
        while (1) {
            memset(luse, 0, sizeof(luse));
            memset(ruse, 0, sizeof(ruse));
            if (find(i)) break;
            int minn = 1e9;
            for (int i = 1; i <= n; i++)
                if (!ruse[i])
                    minn = min(minn, slack[i]);
            for (int i = 1; i <= n; i++) {
                if (luse[i]) l[i] -= minn;
                if (ruse[i]) r[i] += minn;
                else slack[i] -= minn;
            }
        }
    }
    int sum = 0;
    for (int i = 1; i <= n; i++)
        sum += l[i] + r[i];
    return sum;
}
```

注意各个`memset`是在什么位置。